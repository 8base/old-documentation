"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const auth0 = __importStar(require("auth0-js"));
const R = __importStar(require("ramda"));
const utils_1 = require("@8base/utils");
const utils_2 = require("@8base/utils");
const localStorageAccessor = __importStar(require("./localStorageAccessor"));
const DEFAULT_8BASE_API_ENDPOINT = 'https://api.8base.com/';
const isEmptyOrNil = R.either(R.isNil, R.isEmpty);
const isEmailVerified = R.pipe(R.pathOr(undefined, ['idTokenPayload', 'email_verified']), R.equals(true));
const getEmail = R.path(['idTokenPayload', 'email']);
const getIdToken = R.path(['idToken']);
const getIdTokenPayload = R.propOr(undefined, 'idTokenPayload');
const getState = R.propOr(undefined, 'state');
/**
 * Create instacne of the web auth0 auth client.
 * @param {string} domain Domain. See auth0 documentation.
 * @param {string} clientId Client id. See auth0 documentation.
 * @param {string} redirectUri Redurect uri. See auth0 documentation.
 */
class WebAuth0AuthClient {
    constructor(options) {
        this.authorize = (options = {}) => __awaiter(this, void 0, void 0, function* () {
            // @ts-ignore
            this.auth0.authorize(Object.assign({}, options));
        });
        this.renewToken = (options = {}) => new Promise((resolve, reject) => {
            this.auth0.checkSession(options, (error, result) => {
                if (error) {
                    reject(error || {});
                    return;
                }
                resolve({
                    email: getEmail(result),
                    idToken: getIdToken(result),
                    idTokenPayload: getIdTokenPayload(result),
                    isEmailVerified: isEmailVerified(result),
                    state: getState(result),
                });
            });
        });
        this.changePassword = () => __awaiter(this, void 0, void 0, function* () {
            const { email = '' } = yield this.getAuthState();
            return new Promise((resolve, reject) => {
                this.auth0.changePassword({
                    connection: 'Username-Password-Authentication',
                    email,
                }, error => {
                    if (error) {
                        reject(error || {});
                        return;
                    }
                    resolve({ email });
                });
            });
        });
        this.getAuthorizedData = () => {
            return new Promise((resolve, reject) => {
                this.auth0.parseHash((error, authResult) => {
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve({
                        email: getEmail(authResult),
                        idToken: getIdToken(authResult),
                        idTokenPayload: getIdTokenPayload(authResult),
                        isEmailVerified: isEmailVerified(authResult),
                        state: getState(authResult),
                    });
                });
            });
        };
        this.setAuthState = (state) => __awaiter(this, void 0, void 0, function* () {
            localStorageAccessor.setAuthState(state);
        });
        this.getAuthState = () => __awaiter(this, void 0, void 0, function* () { return localStorageAccessor.getAuthState(); });
        this.purgeAuthState = ({ withLogout = false, logoutOptions = {} } = {}) => __awaiter(this, void 0, void 0, function* () {
            localStorageAccessor.purgeAuthState();
            if (withLogout) {
                yield this.logout(logoutOptions);
            }
        });
        this.checkIsAuthorized = () => __awaiter(this, void 0, void 0, function* () {
            const { token } = yield this.getAuthState();
            return R.not(isEmptyOrNil(token));
        });
        this.logout = (options = {}) => __awaiter(this, void 0, void 0, function* () {
            this.auth0.logout(Object.assign({ returnTo: this.logoutRedirectUri }, options));
        });
        utils_1.throwIfMissingRequiredParameters(['domain', 'clientId', 'redirectUri', 'logoutRedirectUri'], utils_2.PACKAGES.WEB_AUTH0_AUTH_CLIENT, options);
        const { domain, clientId, redirectUri, logoutRedirectUri } = options;
        this.logoutRedirectUri = logoutRedirectUri;
        this.auth0 = new auth0.WebAuth({
            clientID: clientId,
            domain,
            // @ts-ignore Check typings. WebAuth options has no mustAcceptTerms property!
            mustAcceptTerms: true,
            redirectUri,
            responseType: 'token id_token',
            scope: 'openid email profile',
        });
    }
}
exports.WebAuth0AuthClient = WebAuth0AuthClient;
//# sourceMappingURL=WebAuth0AuthClient.js.map